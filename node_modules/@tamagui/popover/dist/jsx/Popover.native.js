import "@tamagui/polyfill-dev";
import { Adapt, useAdaptParent } from "@tamagui/adapt";
import { Animate } from "@tamagui/animate";
import { ResetPresence } from "@tamagui/animate-presence";
import { hideOthers } from "@tamagui/aria-hidden";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import {
  Stack,
  Theme,
  View,
  createStyledContext,
  useEvent,
  useGet,
  useMedia,
  useThemeName
} from "@tamagui/core";
import { FloatingOverrideContext } from "@tamagui/floating";
import { FocusScope } from "@tamagui/focus-scope";
import { composeEventHandlers, withStaticProperties } from "@tamagui/helpers";
import {
  Popper,
  PopperAnchor,
  PopperArrow,
  PopperContent,
  PopperContentFrame,
  PopperContext,
  usePopperContext
} from "@tamagui/popper";
import { Portal, PortalHost, PortalItem } from "@tamagui/portal";
import { RemoveScroll } from "@tamagui/remove-scroll";
import { Sheet, SheetController } from "@tamagui/sheet";
import { YStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import * as React from "react";
import { Platform, ScrollView } from "react-native";
import { useFloatingContext } from "./useFloatingContext";
const POPOVER_SCOPE = "PopoverScope", PopoverContext = createStyledContext({}), usePopoverContext = PopoverContext.useStyledContext, PopoverAnchor = React.forwardRef(function(props, forwardedRef) {
  const { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover), { onCustomAnchorAdd, onCustomAnchorRemove } = context || {};
  return React.useEffect(() => (onCustomAnchorAdd(), () => onCustomAnchorRemove()), [onCustomAnchorAdd, onCustomAnchorRemove]), <PopperAnchor
    __scopePopper={__scopePopover || POPOVER_SCOPE}
    {...rest}
    ref={forwardedRef}
  />;
}), PopoverTrigger = React.forwardRef(function(props, forwardedRef) {
  const { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover), anchorTo = context.anchorTo, composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
  if (anchorTo) {
    let virtualRef = {
      current: {
        getBoundingClientRect: () => isWeb ? DOMRect.fromRect(anchorTo) : anchorTo,
        ...!isWeb && {
          measure: (c) => c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height),
          measureInWindow: (c) => c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height)
        }
      }
    };
    return <PopperAnchor
      virtualRef={virtualRef}
      __scopePopper={__scopePopover || POPOVER_SCOPE}
    />;
  }
  if (!props.children)
    return null;
  const trigger = <View
    aria-haspopup="dialog"
    aria-expanded={context.open}
    data-state={getState(context.open)}
    {...rest}
    ref={composedTriggerRef}
    onPress={composeEventHandlers(props.onPress, context.onOpenToggle)}
  />;
  return context.hasCustomAnchor ? trigger : <PopperAnchor __scopePopper={__scopePopover || POPOVER_SCOPE} asChild>{trigger}</PopperAnchor>;
}), PopoverContent = PopperContentFrame.extractable(
  React.forwardRef(function(props, forwardedRef) {
    const {
      allowPinchZoom,
      trapFocus,
      disableRemoveScroll = !0,
      zIndex,
      __scopePopover,
      ...contentImplProps
    } = props, context = usePopoverContext(__scopePopover), contentRef = React.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), isRightClickOutsideRef = React.useRef(!1);
    return React.useEffect(() => {
      if (!context.open)
        return;
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, [context.open]), <PopoverContentPortal __scopePopover={__scopePopover} zIndex={props.zIndex}><Stack pointerEvents={context.open ? "auto" : "none"}><PopoverContentImpl
      {...contentImplProps}
      disableRemoveScroll={disableRemoveScroll}
      ref={composedRefs}
      __scopePopover={__scopePopover}
      trapFocus={trapFocus ?? context.open}
      disableOutsidePointerEvents
      onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {
        var _a;
        event.preventDefault(), isRightClickOutsideRef.current || (_a = context.triggerRef.current) == null || _a.focus();
      })}
      onPointerDownOutside={composeEventHandlers(
        props.onPointerDownOutside,
        (event) => {
          const originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.current = isRightClick;
        },
        { checkDefaultPrevented: !1 }
      )}
      onFocusOutside={composeEventHandlers(
        props.onFocusOutside,
        (event) => event.preventDefault(),
        { checkDefaultPrevented: !1 }
      )}
    /></Stack></PopoverContentPortal>;
  })
);
function PopoverRepropagateContext(props) {
  return <PopperContext.Provider scope={props.scope} {...props.popperContext}><PopoverContext.Provider {...props.context}>{props.children}</PopoverContext.Provider></PopperContext.Provider>;
}
function PopoverContentPortal(props) {
  const { __scopePopover } = props, zIndex = props.zIndex ?? 15e4, context = usePopoverContext(__scopePopover), popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE), themeName = useThemeName();
  let contents = props.children;
  return (Platform.OS === "android" || Platform.OS === "ios") && (contents = <PopoverRepropagateContext
    scope={__scopePopover || POPOVER_SCOPE}
    popperContext={popperContext}
    context={context}
  >{props.children}</PopoverRepropagateContext>), <Portal zIndex={zIndex}>
    {
      /* forceClassName avoids forced re-mount renders for some reason... see the HeadMenu as you change tints a few times */
    }
    {
      /* without this you'll see the site menu re-rendering. It must be something in wrapping children in Theme */
    }
    <Theme forceClassName name={themeName}>
      {!!context.open && !context.breakpointActive && <YStack
        fullscreen
        onPress={composeEventHandlers(props.onPress, context.onOpenToggle)}
      />}
      {contents}
    </Theme>
  </Portal>;
}
const PopoverContentImpl = React.forwardRef(function(props, forwardedRef) {
  const {
    trapFocus,
    __scopePopover,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    disableFocusScope,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    children,
    disableRemoveScroll,
    freezeContentsWhenHidden,
    ...contentProps
  } = props, context = usePopoverContext(__scopePopover), { open, keepChildrenMounted } = context, popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE), [isFullyHidden, setIsFullyHidden] = React.useState(!context.open), contents = React.useMemo(() => isWeb ? <div style={{ display: "contents" }}>{children}</div> : children, [children]);
  if (open && isFullyHidden && setIsFullyHidden(!1), !keepChildrenMounted && isFullyHidden)
    return null;
  if (context.breakpointActive) {
    const childrenWithoutScrollView = React.Children.toArray(children).map((child) => React.isValidElement(child) && child.type === ScrollView ? child.props.children : child);
    let content = childrenWithoutScrollView;
    return Platform.OS === "android" || Platform.OS === "ios" ? content = <PopperContext.Provider
      scope={__scopePopover || POPOVER_SCOPE}
      {...popperContext}
    ><ResetPresence>{childrenWithoutScrollView}</ResetPresence></PopperContext.Provider> : content = <ResetPresence>{content}</ResetPresence>, <PortalItem hostName={`${context.id}PopoverContents`}>{content}</PortalItem>;
  }
  return <Animate
    type="presence"
    present={!!open}
    keepChildrenMounted={keepChildrenMounted}
    onExitComplete={() => {
      setIsFullyHidden(!0);
    }}
  ><PopperContent
    __scopePopper={__scopePopover || POPOVER_SCOPE}
    key={context.contentId}
    data-state={getState(open)}
    id={context.contentId}
    ref={forwardedRef}
    {...contentProps}
  ><RemoveScroll
    enabled={disableRemoveScroll ? !1 : open}
    allowPinchZoom
    removeScrollBar={!1}
    style={{
      display: "contents"
    }}
  ><ResetPresence><FocusScope
    loop
    enabled={disableFocusScope ? !1 : open}
    trapped={trapFocus}
    onMountAutoFocus={onOpenAutoFocus}
    onUnmountAutoFocus={onCloseAutoFocus}
  >{contents}</FocusScope></ResetPresence></RemoveScroll></PopperContent></Animate>;
}), PopoverClose = React.forwardRef(function(props, forwardedRef) {
  const { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover);
  return <YStack
    {...rest}
    ref={forwardedRef}
    componentName="PopoverClose"
    onPress={composeEventHandlers(
      props.onPress,
      () => context.onOpenChange(!1)
    )}
  />;
}), PopoverArrow = PopperArrow.styleable(function(props, forwardedRef) {
  const { __scopePopover, ...rest } = props, context = usePopoverContext(__scopePopover);
  return useSheetBreakpointActive(context.sheetBreakpoint) ? null : <PopperArrow
    __scopePopper={__scopePopover || POPOVER_SCOPE}
    componentName="PopoverArrow"
    {...rest}
    ref={forwardedRef}
  />;
}), Popover = withStaticProperties(
  React.forwardRef(
    (props, forwardedRef) => {
      const {
        children,
        open: openProp,
        defaultOpen,
        onOpenChange,
        __scopePopover,
        keepChildrenMounted,
        hoverable,
        disableFocus,
        ...restProps
      } = props, id = React.useId(), { when, AdaptProvider } = useAdaptParent({
        Contents: React.useCallback(() => <PortalHost name={`${id}PopoverContents`} />, [])
      }), sheetBreakpoint = when, triggerRef = React.useRef(null), [hasCustomAnchor, setHasCustomAnchor] = React.useState(!1), [open, setOpen] = useControllableState({
        prop: openProp,
        defaultProp: defaultOpen || !1,
        onChange: onOpenChange
      }), sheetActive = useSheetBreakpointActive(sheetBreakpoint), floatingContext = useFloatingContext({
        open,
        setOpen,
        disable: sheetActive,
        hoverable,
        disableFocus
      }), [anchorTo, setAnchorTo] = React.useState();
      React.useImperativeHandle(forwardedRef, () => ({
        anchorTo: setAnchorTo
      }));
      const popoverContext = {
        id,
        sheetBreakpoint,
        contentId: React.useId(),
        triggerRef,
        open,
        breakpointActive: sheetActive,
        onOpenChange: setOpen,
        onOpenToggle: useEvent(() => {
          open && sheetActive || setOpen(!open);
        }),
        hasCustomAnchor,
        anchorTo,
        onCustomAnchorAdd: React.useCallback(() => setHasCustomAnchor(!0), []),
        onCustomAnchorRemove: React.useCallback(() => setHasCustomAnchor(!1), []),
        keepChildrenMounted
      }, contents = <Popper
        __scopePopper={__scopePopover || POPOVER_SCOPE}
        stayInFrame
        {...restProps}
      ><PopoverContext.Provider scope={__scopePopover} {...popoverContext}><PopoverSheetController onOpenChange={setOpen}>{children}</PopoverSheetController></PopoverContext.Provider></Popper>;
      return <AdaptProvider>{isWeb ? <FloatingOverrideContext.Provider value={floatingContext}>{contents}</FloatingOverrideContext.Provider> : contents}</AdaptProvider>;
    }
  ),
  {
    Anchor: PopoverAnchor,
    Arrow: PopoverArrow,
    Trigger: PopoverTrigger,
    Content: PopoverContent,
    Close: PopoverClose,
    Adapt,
    ScrollView,
    Sheet: Sheet.Controlled
  }
);
function getState(open) {
  return open ? "open" : "closed";
}
const PopoverSheetController = ({
  __scopePopover,
  ...props
}) => {
  const context = usePopoverContext(__scopePopover), showSheet = useShowPopoverSheet(context), breakpointActive = context.breakpointActive, getShowSheet = useGet(showSheet);
  return <SheetController
    onOpenChange={(val) => {
      getShowSheet() && props.onOpenChange(val);
    }}
    open={context.open}
    hidden={breakpointActive === !1}
  >{props.children}</SheetController>;
}, useSheetBreakpointActive = (breakpoint) => {
  const media = useMedia();
  return typeof breakpoint == "boolean" || !breakpoint ? !!breakpoint : media[breakpoint];
}, useShowPopoverSheet = (context) => {
  const breakpointActive = useSheetBreakpointActive(context.sheetBreakpoint);
  return context.open === !1 ? !1 : breakpointActive;
};
export {
  Popover,
  PopoverAnchor,
  PopoverArrow,
  PopoverClose,
  PopoverContent,
  PopoverContext,
  PopoverTrigger,
  usePopoverContext
};
//# sourceMappingURL=Popover.js.map
