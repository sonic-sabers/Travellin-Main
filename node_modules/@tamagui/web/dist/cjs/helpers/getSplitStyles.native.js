"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var getSplitStyles_exports = {};
__export(getSplitStyles_exports, {
  PROP_SPLIT: () => PROP_SPLIT,
  getSplitStyles: () => getSplitStyles,
  getSubStyle: () => getSubStyle,
  useSplitStyles: () => useSplitStyles
});
module.exports = __toCommonJS(getSplitStyles_exports);
var import_constants = require("@tamagui/constants"), import_helpers = require("@tamagui/helpers"), import_react = require("react"), import_config = require("../config"), import_accessibilityDirectMap = require("../constants/accessibilityDirectMap"), import_constants2 = require("../constants/constants"), import_isDevTools = require("../constants/isDevTools"), import_useMedia = require("../hooks/useMedia"), import_createMediaStyle = require("./createMediaStyle"), import_expandStyles = require("./expandStyles"), import_getGroupPropParts = require("./getGroupPropParts"), import_getStylesAtomic = require("./getStylesAtomic"), import_insertStyleRule = require("./insertStyleRule"), import_log = require("./log"), import_normalizeValueWithProperty = require("./normalizeValueWithProperty"), import_propMapper = require("./propMapper"), import_pseudoDescriptors = require("./pseudoDescriptors");
const IS_STATIC = process.env.IS_STATIC === "is_static";
let conf;
const PROP_SPLIT = "-";
function isValidStyleKey(key, staticConfig) {
  return (staticConfig.validStyles || (staticConfig.isText ? import_helpers.stylePropsText : import_helpers.validStyles))[key] || staticConfig.acceptTokens && staticConfig.acceptTokens[key];
}
const getSplitStyles = (props, staticConfig, theme, themeName, componentState, styleProps, parentSplitStyles, context, elementType, debug) => {
  var _a, _b, _c, _e, _f, _g;
  conf = conf || (0, import_config.getConfig)(), import_constants.isWeb && styleProps.isAnimated && conf.animations.isReactNative && !styleProps.noNormalize && (styleProps.noNormalize = "values");
  const { shorthands } = conf, {
    isHOC,
    isText,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState = styleProps.mediaState || import_useMedia.mediaState, usedKeys = {}, shouldDoClasses = acceptsClassName && import_constants.isWeb && !styleProps.noClassNames, rulesToInsert = [], classNames = {}, transforms = {};
  let pseudos = null, space = props.space, hasMedia = !1, dynamicThemeAccess, pseudoGroups, mediaGroups, style = {}, className = props.className ?? "", mediaStylesSeen = 0;
  const styleState = {
    curProps: { ...props },
    classNames,
    conf,
    props,
    styleProps,
    componentState,
    staticConfig,
    style,
    theme,
    usedKeys,
    viewProps,
    context,
    debug
  };
  process.env.NODE_ENV === "development" && debug && debug !== "profile" && import_constants.isClient && (console.groupCollapsed("getSplitStyles (collapsed)"), (0, import_log.log)({
    props,
    staticConfig,
    shouldDoClasses,
    styleProps,
    componentState,
    styleState,
    theme: { ...theme }
  }), console.groupEnd());
  for (const keyOg in props) {
    let keyInit = keyOg, valInit = props[keyOg];
    if (styleProps.disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className" || keyInit in usedKeys || keyInit in skipProps && !styleProps.noSkip && !isHOC)
      continue;
    const valInitType = typeof valInit, isValidStyleKeyInit = isValidStyleKey(keyInit, staticConfig);
    if (styleState.curProps[keyInit] = valInit, !import_constants.isAndroid && keyInit === "elevationAndroid")
      continue;
    if (keyInit === "userSelect")
      keyInit = "selectable", valInit = valInit !== "none";
    else if (keyInit === "role") {
      viewProps.accessibilityRole = import_accessibilityDirectMap.accessibilityWebRoleToNativeRole[valInit];
      continue;
    } else if (keyInit.startsWith("aria-")) {
      if (import_accessibilityDirectMap.webToNativeAccessibilityDirectMap[keyInit]) {
        const nativeA11yProp = import_accessibilityDirectMap.webToNativeAccessibilityDirectMap[keyInit];
        keyInit === "aria-hidden" && (viewProps["aria-hidden"] = valInit), viewProps[nativeA11yProp] = valInit;
        continue;
      }
      if (import_accessibilityDirectMap.nativeAccessibilityValue[keyInit]) {
        let field = import_accessibilityDirectMap.nativeAccessibilityValue[keyInit];
        viewProps.accessibilityValue ? viewProps.accessibilityValue[field] = valInit : viewProps.accessibilityValue = {
          [field]: valInit
        };
      } else if (import_accessibilityDirectMap.nativeAccessibilityState[keyInit]) {
        let field = import_accessibilityDirectMap.nativeAccessibilityState[keyInit];
        viewProps.accessibilityState ? viewProps.accessibilityState[field] = valInit : viewProps.accessibilityState = {
          [field]: valInit
        };
      }
      continue;
    } else if (keyInit.startsWith("data-"))
      continue;
    if (keyInit === "dataSet") {
      for (const keyInit2 in valInit)
        viewProps[`data-${hyphenate(keyInit2)}`] = valInit[keyInit2];
      continue;
    }
    if (keyInit[0] === "_" && keyInit.startsWith("_style")) {
      mergeStylePropIntoStyle(styleState, valInit);
      continue;
    }
    if (0 && !styleProps.noExpand && !isReactNative)
      switch (keyInit) {
        case "accessibilityRole":
        case "accessibilityLabelledBy":
        case "accessibilityFlowTo":
        case "accessibilityControls":
        case "accessibilityDescribedBy":
        case "accessibilityKeyShortcuts":
        case "accessibilityLiveRegion":
        case "accessibilityReadOnly":
        case "accessibilityRequired":
        default:
      }
    const isShorthand = keyInit in shorthands;
    let isVariant = !isValidStyleKeyInit && variants && keyInit in variants;
    const isStyleLikeKey = isShorthand || isValidStyleKeyInit || isVariant;
    let isPseudo = keyInit in import_helpers.validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo && (0, import_useMedia.isMediaKey)(keyInit), isMediaOrPseudo = !!(isMedia || isPseudo);
    const isStyleProp = isMediaOrPseudo || isVariant && !styleProps.noExpand || isValidStyleKeyInit || isShorthand;
    if (isStyleProp && (props.asChild === "except-style" || props.asChild === "except-style-web"))
      continue;
    const shouldPassProp = !isStyleProp || // is in parent variants
    isHOC && (parentStaticConfig == null ? void 0 : parentStaticConfig.variants) && keyInit in parentStaticConfig.variants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = (_a = parentStaticConfig == null ? void 0 : parentStaticConfig.variants) == null ? void 0 : _a[keyInit], isHOCShouldPassThrough = !!(isHOC && (isShorthand || isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed(
      `  \u{1F511} ${keyOg}${keyInit !== keyOg ? ` (shorthand for ${keyInit})` : ""} ${shouldPassThrough ? "(pass)" : ""}`
    ), (0, import_log.log)({ isVariant, valInit, shouldPassProp }), import_constants.isClient && (0, import_log.log)({
      variants,
      variant: variants == null ? void 0 : variants[keyInit],
      isVariant,
      isHOCShouldPassThrough,
      curProps: { ...styleState.curProps },
      parentStaticConfig
    }), console.groupEnd()), shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant) || !styleProps.noSkip && keyInit in skipProps)
      continue;
    if (isText && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit), isValidStyleKeyInit && !variants && valInit !== "unset" && (valInitType === "number" || valInitType === "string" && valInit[0] !== "$")) {
      style[keyInit] = valInit;
      continue;
    }
    const expanded = isMediaOrPseudo || !isVariant && !isValidStyleKeyInit ? [[keyInit, valInit]] : (0, import_propMapper.propMapper)(keyInit, valInit, styleState), next = (0, import_propMapper.getPropMappedFontFamily)(expanded);
    if (next && (styleState.fontFamily = next), process.env.NODE_ENV === "development" && debug === "verbose") {
      console.groupCollapsed("  \u{1F4A0} expanded", keyInit, valInit);
      try {
        !import_constants.isServer && import_isDevTools.isDevTools && ((0, import_log.log)({
          expanded,
          styleProps,
          componentState,
          isVariant,
          variant: variants == null ? void 0 : variants[keyInit],
          shouldPassProp,
          isHOCShouldPassThrough,
          theme,
          usedKeys: { ...usedKeys },
          curProps: { ...styleState.curProps }
        }), (0, import_log.log)("expanded", expanded, `
usedKeys`, { ...usedKeys }, `
current`, {
          ...style
        }));
      } catch {
      }
      console.groupEnd();
    }
    if (expanded) {
      for (const [key, val] of expanded) {
        if (val == null || key in usedKeys)
          continue;
        if (isPseudo = key in import_helpers.validPseudoKeys, isMedia = !isPseudo && !isValidStyleKeyInit && (0, import_useMedia.isMediaKey)(key), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key in variants, (inlineProps != null && inlineProps.has(key) || IS_STATIC && (inlineWhenUnflattened != null && inlineWhenUnflattened.has(key))) && (viewProps[key] = props[key] ?? val), styleProps.noExpand && isPseudo || isHOC && (isMediaOrPseudo || ((_b = parentStaticConfig == null ? void 0 : parentStaticConfig.variants) == null ? void 0 : _b[keyInit]))) {
          passDownProp(viewProps, key, val, isMediaOrPseudo), process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed(` - passing down prop ${key}`), (0, import_log.log)({ val, after: { ...viewProps[key] } }), console.groupEnd());
          continue;
        }
        if (isPseudo) {
          if (!val)
            continue;
          const pseudoStyleObject = getSubStyle(
            styleState,
            key,
            val,
            styleProps.noClassNames
          ), descriptor = import_pseudoDescriptors.pseudoDescriptors[key], isEnter = key === "enterStyle", isExit = key === "exitStyle";
          if (!descriptor || isExit && !styleProps.isExiting)
            continue;
          if ((!shouldDoClasses || IS_STATIC) && (pseudos ||= {}, pseudos[key] ||= {}, IS_STATIC)) {
            Object.assign(pseudos[key], pseudoStyleObject);
            continue;
          }
          if (shouldDoClasses && !isExit) {
            const pseudoStyles = (0, import_getStylesAtomic.generateAtomicStyles)(pseudoStyleObject, descriptor);
            process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("pseudo (classes)", key), (0, import_log.log)({ pseudoStyleObject, pseudoStyles }), console.groupEnd());
            for (const psuedoStyle of pseudoStyles) {
              const fullKey = `${psuedoStyle.property}${PROP_SPLIT}${descriptor.name}`;
              fullKey in usedKeys || (psuedoStyle.identifier, void 0);
            }
          }
          if (!shouldDoClasses || isExit || isEnter) {
            const descriptorKey = descriptor.stateKey || descriptor.name;
            let isDisabled = componentState[descriptorKey] === !1;
            isExit && (isDisabled = !styleProps.isExiting), isEnter && (isDisabled = componentState.unmounted === "should-enter" ? !0 : !componentState.unmounted), process.env.NODE_ENV === "development" && debug === "verbose" && (console.groupCollapsed("pseudo", key, { isDisabled }), (0, import_log.log)({ pseudoStyleObject, isDisabled, descriptor, componentState }), console.groupEnd());
            const importance = descriptor.priority;
            for (const pkey in pseudoStyleObject) {
              const val2 = pseudoStyleObject[pkey];
              if (isDisabled) {
                if (pkey in animatableDefaults && !(pkey in usedKeys)) {
                  const defaultVal = animatableDefaults[pkey];
                  mergeStyle(styleState, pkey, defaultVal);
                }
              } else {
                const curImportance = usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                shouldMerge && (pseudos ||= {}, pseudos[key] ||= {}, pseudos[key][pkey] = val2, mergeStyle(styleState, pkey, val2)), process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("    subKey", pkey, shouldMerge, {
                  importance,
                  curImportance,
                  pkey,
                  val: val2,
                  transforms: { ...styleState.transforms }
                });
              }
            }
            if (!isDisabled)
              for (const key2 in val) {
                const k = shorthands[key2] || key2;
                usedKeys[k] = Math.max(importance, usedKeys[k] || 0);
              }
          }
          continue;
        }
        if (isMedia) {
          if (!val)
            continue;
          if (isMedia === "platform") {
            const platform = key.slice(10);
            if (
              // supports web, ios, android
              platform !== import_constants.currentPlatform && // supports web, native
              platform !== "native"
            )
              continue;
          }
          hasMedia ||= !0;
          const mediaStyle = getSubStyle(
            styleState,
            key,
            val,
            // TODO try true like pseudo
            !1
          ), mediaKeyShort = key.slice(1);
          process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(`  \u{1F4FA} ${key}`, {
            key,
            val,
            mediaStyle,
            props,
            shouldDoClasses,
            componentState
          });
          const hasSpace = val.space;
          if ((hasSpace || !shouldDoClasses) && (Array.isArray(hasMedia) || (hasMedia = []), hasMedia.push(mediaKeyShort)), shouldDoClasses) {
            if (hasSpace && (delete mediaStyle.space, mediaState[mediaKeyShort])) {
              const importance = (0, import_useMedia.getMediaImportanceIfMoreImportant)(
                mediaKeyShort,
                "space",
                usedKeys,
                !0
              );
              importance && (space = val.space, usedKeys.space = importance, process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)(
                `Found more important space for current media ${mediaKeyShort}: ${val} (importance: ${importance})`
              ));
            }
            const mediaStyles = (0, import_getStylesAtomic.getStylesAtomic)(mediaStyle, debug), priority = mediaStylesSeen;
            mediaStylesSeen += 1;
            for (const style2 of mediaStyles) {
              const out = (0, import_createMediaStyle.createMediaStyle)(
                style2,
                mediaKeyShort,
                import_useMedia.mediaQueryConfig,
                isMedia,
                !1,
                priority
              );
              process.env.NODE_ENV === "development" && debug === "verbose" && (0, import_log.log)("\u{1F4FA} media style:", out);
              const fullKey = `${style2.property}${PROP_SPLIT}${mediaKeyShort}`;
              fullKey in usedKeys || (out.identifier, void 0);
            }
          } else {
            const isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group";
            if (!isThemeMedia && !(isMedia === "platform") && !isGroupMedia && !mediaState[mediaKeyShort])
              continue;
            let importanceBump = 0;
            if (isThemeMedia) {
              dynamicThemeAccess = !0;
              const mediaThemeName = mediaKeyShort.slice(6);
              if (!(themeName === mediaThemeName || themeName.startsWith(mediaThemeName)))
                continue;
            } else if (isGroupMedia) {
              const groupInfo = (0, import_getGroupPropParts.getGroupPropParts)(mediaKeyShort), groupName = groupInfo.name, groupContext = context == null ? void 0 : context.groups.state[groupName];
              if (!groupContext) {
                process.env.NODE_ENV === "development" && debug && console.warn(`No parent with group prop, skipping styles: ${groupName}`);
                continue;
              }
              const groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media, componentGroupState = (_c = componentState.group) == null ? void 0 : _c[groupName];
              if (groupMediaKey) {
                mediaGroups ||= /* @__PURE__ */ new Set(), mediaGroups.add(groupMediaKey);
                const mediaState2 = componentGroupState == null ? void 0 : componentGroupState.media;
                let isActive = mediaState2 == null ? void 0 : mediaState2[groupMediaKey];
                if (!mediaState2 && groupContext.layout && (isActive = (0, import_useMedia.mediaKeyMatch)(groupMediaKey, groupContext.layout)), !isActive)
                  continue;
                importanceBump = 2;
              }
              if (groupPseudoKey) {
                pseudoGroups ||= /* @__PURE__ */ new Set(), pseudoGroups.add(groupName);
                const componentGroupPseudoState = (componentGroupState || // fallback to context initially
                context.groups.state[groupName]).pseudo;
                if (!(componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey]))
                  continue;
                importanceBump = import_pseudoDescriptors.pseudoPriorities[groupPseudoKey];
              }
            }
            for (const subKey in mediaStyle) {
              if (subKey === "space") {
                space = valInit.space;
                continue;
              }
              (0, import_useMedia.mergeMediaByImportance)(
                style,
                mediaKeyShort,
                subKey,
                mediaStyle[subKey],
                usedKeys,
                mediaState[mediaKeyShort],
                importanceBump
              ), key === "fontFamily" && (styleState.fontFamily = mediaStyle.fontFamily);
            }
          }
          continue;
        }
        if (key === "pointerEvents") {
          viewProps[key] = val;
          continue;
        }
        if (
          // is HOC we can just pass through the styles as props
          // this fixes issues where style prop got merged with wrong priority
          !isHOC && (isValidStyleKey(key, staticConfig) || import_constants.isAndroid && key === "elevation")
        ) {
          mergeStyle(styleState, key, val);
          continue;
        }
        isVariant || (viewProps[key] = val);
      }
      if (process.env.NODE_ENV === "development" && debug === "verbose") {
        console.groupCollapsed(" \u2714\uFE0F expand complete", keyInit);
        try {
          (0, import_log.log)("style", { ...style }), (0, import_log.log)("transforms", { ...transforms }), (0, import_log.log)("viewProps", { ...viewProps });
        } catch {
        }
        console.groupEnd();
      }
    }
  }
  if (props.style && mergeStylePropIntoStyle(styleState, props.style), !(styleProps.noNormalize === !1) && ((0, import_expandStyles.fixStyles)(style), import_constants.isWeb && !staticConfig.isReactNative && (0, import_getStylesAtomic.styleToCSS)(style), styleState.transforms && Object.entries(styleState.transforms).sort(([a], [b]) => a.localeCompare(b)).forEach(([key, val]) => {
    mergeTransform(style, key, val, !0);
  }), parentSplitStyles && !shouldDoClasses))
    for (const key in parentSplitStyles.style)
      key in classNames || key in style || (style[key] = parentSplitStyles.style[key]);
  const result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    // @ts-expect-error
    style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups
  };
  if (style.fontFamily) {
    const faceInfo = (_e = (0, import_config.getFont)(style.fontFamily)) == null ? void 0 : _e.face;
    if (faceInfo) {
      const overrideFace = (_g = (_f = faceInfo[style.fontWeight]) == null ? void 0 : _f[style.fontStyle || "normal"]) == null ? void 0 : _g.val;
      overrideFace && (style.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style.fontWeight, delete style.fontStyle);
    }
    process.env.NODE_ENV === "development" && debug && debug !== "profile" && (0, import_log.log)(`Found fontFamily native: ${style.fontFamily}`, faceInfo);
  }
  if (className && (classNames.className = className), process.env.NODE_ENV === "development" && debug === "verbose" && import_isDevTools.isDevTools) {
    console.groupCollapsed("\u{1F539} getSplitStyles ===>");
    try {
      const logs = {
        ...result,
        className,
        componentState,
        transforms,
        viewProps,
        viewPropsOrder: Object.keys(viewProps),
        rulesToInsert,
        parentSplitStyles
      };
      for (const key in logs)
        (0, import_log.log)(key, logs[key]);
    } catch {
    }
    console.groupEnd();
  }
  return result;
};
function mergeStyle(styleState, key, val, disableNormalize = !1) {
  const { classNames, viewProps, style, usedKeys, styleProps } = styleState;
  if (import_constants.isWeb && (val == null ? void 0 : val[0]) === "_")
    classNames[key] = val, usedKeys[key] ||= 1;
  else if (key in import_helpers.stylePropsTransform)
    styleState.transforms ||= {}, styleState.transforms[key] = val;
  else {
    const out = import_constants.isWeb && !disableNormalize && !styleProps.noNormalize ? (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(val, key) : val;
    key in import_helpers.validStylesOnBaseProps ? viewProps[key] = out : style[key] = out;
  }
}
const getSubStyle = (styleState, subKey, styleIn, avoidMergeTransform) => {
  const { staticConfig, props, conf: conf2, styleProps } = styleState, styleOut = {};
  for (let key in styleIn) {
    const val = styleIn[key];
    key = conf2.shorthands[key] || key;
    const expanded = (0, import_propMapper.propMapper)(key, val, styleState, { ...props, ...props[subKey] });
    if (!(!expanded || !staticConfig.isHOC && key in skipProps && !styleProps.noSkip))
      for (const [skey, sval] of expanded)
        !avoidMergeTransform && skey in import_helpers.stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps.noNormalize ? sval : (0, import_normalizeValueWithProperty.normalizeValueWithProperty)(sval, key);
  }
  return styleProps.noNormalize || (0, import_expandStyles.fixStyles)(styleOut), styleOut;
};
function mergeStylePropIntoStyle(styleState, cur) {
  if (!cur)
    return;
  const styles = Array.isArray(cur) ? cur : [cur];
  for (const style of styles) {
    if (!style)
      continue;
    const isRNW = style.$$css;
    Object.assign(isRNW ? styleState.classNames : styleState.style, style);
  }
}
const useInsertEffectCompat = import_constants.isWeb ? import_react.useInsertionEffect || import_constants.useIsomorphicLayoutEffect : () => {
}, useSplitStyles = (...args) => {
  const res = getSplitStyles(...args);
  return useInsertEffectCompat(() => {
    (0, import_insertStyleRule.insertStyleRules)(res.rulesToInsert);
  }, [res.rulesToInsert]), res;
};
const animatableDefaults = {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0
}, lowercaseHyphenate = (match) => `-${match.toLowerCase()}`, hyphenate = (str) => str.replace(/[A-Z]/g, lowercaseHyphenate), mergeTransform = (obj, key, val, backwards = !1) => {
  typeof obj.transform != "string" && (obj.transform ||= [], obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
}, skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1
};
process.env.NODE_ENV === "test" && (skipProps["data-test-renders"] = 1);
Object.assign(skipProps, {
  whiteSpace: 1,
  wordWrap: 1,
  textOverflow: 1,
  textDecorationDistance: 1,
  cursor: 1,
  contain: 1,
  boxSizing: 1,
  boxShadow: 1,
  outlineStyle: 1,
  outlineOffset: 1,
  outlineWidth: 1,
  outlineColor: 1
});
function passDownProp(viewProps, key, val, shouldMergeObject = !1) {
  if (shouldMergeObject) {
    const next = {
      ...viewProps[key],
      ...val
    };
    delete viewProps[key], viewProps[key] = next;
  } else
    viewProps[key] = val;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PROP_SPLIT,
  getSplitStyles,
  getSubStyle,
  useSplitStyles
});
//# sourceMappingURL=getSplitStyles.js.map
