var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var createAnimations_exports = {};
__export(createAnimations_exports, {
  createAnimations: () => createAnimations
});
module.exports = __toCommonJS(createAnimations_exports);
var import_use_presence = require("@tamagui/use-presence"), import_author = require("moti/author"), import_react = require("react"), import_react_native_reanimated = __toESM(require("react-native-reanimated"));
function createAnimations(animations) {
  return {
    View: import_react_native_reanimated.default.View,
    Text: import_react_native_reanimated.default.Text,
    isReactNative: !0,
    animations,
    usePresence: import_use_presence.usePresence,
    ResetPresence: import_use_presence.ResetPresence,
    useAnimatedNumber(initial) {
      const sharedValue = (0, import_react_native_reanimated.useSharedValue)(initial);
      return (0, import_react.useMemo)(
        () => ({
          getInstance() {
            "worklet";
            return sharedValue;
          },
          getValue() {
            "worklet";
            return sharedValue.value;
          },
          setValue(next, config = { type: "spring" }) {
            "worklet";
            config.type === "direct" ? sharedValue.value = next : config.type === "spring" ? sharedValue.value = (0, import_react_native_reanimated.withSpring)(next, config) : sharedValue.value = (0, import_react_native_reanimated.withTiming)(next, config);
          },
          stop() {
            "worklet";
            (0, import_react_native_reanimated.cancelAnimation)(sharedValue);
          }
        }),
        [sharedValue]
      );
    },
    useAnimatedNumberReaction({ value }, onValue) {
      const instance = value.getInstance();
      return (0, import_react_native_reanimated.useAnimatedReaction)(
        () => instance.value,
        (next, prev) => {
          prev !== next && (0, import_react_native_reanimated.runOnJS)(onValue)(next);
        },
        // dependency array is very important here
        [onValue, instance]
      );
    },
    /**
     * `getStyle` must be a worklet
     */
    useAnimatedNumberStyle(val, getStyle) {
      const instance = val.getInstance(), derivedValue = (0, import_react_native_reanimated.useDerivedValue)(() => instance.value, [instance, getStyle]);
      return (0, import_react_native_reanimated.useAnimatedStyle)(() => getStyle(derivedValue.value), [val, getStyle, derivedValue, instance]);
    },
    useAnimations: (animationProps) => {
      const { props, presence, style, onDidAnimate, componentState } = animationProps, animationKey = Array.isArray(props.animation) ? props.animation[0] : props.animation, isHydrating = componentState.unmounted === "should-enter";
      let animate = {}, dontAnimate = {};
      if (isHydrating)
        dontAnimate = style;
      else {
        const animateOnly = props.animateOnly || ["transform", "opacity"];
        if (animateOnly) {
          dontAnimate = { ...style };
          for (const key of animateOnly)
            key in style && (animate[key] = style[key], delete dontAnimate[key]);
        } else
          animate = style;
      }
      const animateStr = JSON.stringify(animate), styles = (0, import_react.useMemo)(() => JSON.parse(animateStr), [animateStr]), isExiting = !!(presence != null && presence[1]), sendExitComplete = presence == null ? void 0 : presence[1], onDidAnimateCombined = (0, import_react.useCallback)(() => {
        onDidAnimate == null || onDidAnimate(), sendExitComplete == null || sendExitComplete();
      }, []), motiProps = {
        animate: isExiting || isHydrating ? {} : styles,
        transition: animations[animationKey],
        // isHydrating
        //   ? ({ type: 'timing', duration: 0 } as const)
        //   : componentState.unmounted
        //     ? { type: 'timing', duration: 0 }
        //     : animations[animationKey as keyof typeof animations]
        onDidAnimate: onDidAnimateCombined,
        usePresenceValue: presence,
        presenceContext: (0, import_react.useContext)(import_use_presence.PresenceContext),
        exit: isExiting ? styles : void 0
      }, moti = (0, import_author.useMotify)(motiProps);
      return process.env.NODE_ENV === "development" && props.debug && console.info("useMotify(", JSON.stringify(motiProps, null, 2) + ")", {
        animationProps,
        motiProps,
        moti,
        style: [dontAnimate, moti.style]
      }), {
        style: [dontAnimate, moti.style]
      };
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createAnimations
});
//# sourceMappingURL=createAnimations.js.map
